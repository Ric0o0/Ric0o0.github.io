[{"title":"找出栈中最小的元素, 要求时间复杂度O(1)","url":"/Ric0o0/2021/06/07/GetMinStactk/","content":"找出栈最小的元素, 大部分情况首先想到的就是遍历, 但时间复杂度不为1, 所以我们要从最开始就需要筛选最小的元素思路很简单, 准备两个栈, 这里用Array来代替, 其中一个是正常的arr, 另一个用来存放最小值, 称它为minArr\nminArr中存放的为当前最小的元素\narr[3, 2, 1, 3, 2, 1, 0]   minArr[3, 2, 1, 1, 1, 1, 0]\n每次执行push入栈操作的时候, arr 与 minArr 同时push, arr.push(输入的value), 在minArr.push()时需要进行判断, 如果 \n\nminArr数组中的最后一个数 &gt; value   –&gt; minArr要push的还是最后一个数, 而不是新的value\n\n在第二次 push(3) 时, arr [3, 2, 1, 3]   minArr[3, 2, 1, 1]\n最后一个元素1 &lt; 3  , 所以继续存1 , 而不是3 , 这样在取最小值的时候,直接取minArr最后一个即可\n\n\n如果最后一个数 &lt; value  –&gt;  minArr就要push这个新的value .\n\n\n// 取出栈中的最小值, 要求时间复杂度O(1)class MyStack1 &#123;    constructor () &#123;        this.arr = [];        this.minArr = [];    &#125;    push(value)&#123;        if (this.arr.length === 0)&#123;            this.minArr.push(value)        &#125; else if (value &lt; this.getMin())&#123;  // 当前值小于最小栈顶的值            this.minArr.push(value)        &#125; else &#123;            this.minArr.push(this.minArr[this.minArr.length-1])        &#125;        this.arr.push(value)    &#125;    pop()&#123;        if (this.arr.length === 0)&#123;            console.log(&#x27;空表!&#x27;)            return -1        &#125;        this.minArr.pop()  // 弹出就是两个一起弹        this.arr.pop()    &#125;    getMin()&#123;        return this.minArr[this.minArr.length-1]    &#125;&#125;let ms = new MyStack1()ms.push(5)ms.push(6)ms.push(6)ms.push(4)ms.push(4)ms.push(8)// ms.pop()console.log(ms.getMin())console.log(ms)\n\n"},{"title":"Hello World","url":"/Ric0o0/2021/05/07/hello-world/","content":"\n\nWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"vue输入框防抖.md","url":"/Ric0o0/2021/05/15/vue%E8%BE%93%E5%85%A5%E6%A1%86%E9%98%B2%E6%8A%96-md/","content":"Vue踩坑之(一) —— Vue中input防抖在有道网页翻译中，无意间发现这样一个功能，恰好我正在写一个小项目，其中一个功能就需要，在input输入框中输入，然后根据输入内容调用api，但是如果输入速度太快不能无限制调用，需要加防抖  \n直接上代码\n&lt;template&gt;  &lt;div id=&quot;addword&quot;&gt;    &lt;p&gt;添加单词&lt;/p&gt;    &lt;input type=&quot;text&quot; v-model=&quot;iText&quot; @input=&quot;debounce(verifyWord, 500)()&quot;&gt;  &lt;!--必须调用返回的函数--&gt;    &lt;p&gt;&#123;&#123; vword &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;AddWord&#x27;,  data () &#123;    return &#123;      iText: &#x27;&#x27;,  // input中的值      vword: &#x27;&#x27;,  // 要显示的值      timer: null,  // 定时器    &#125;  &#125;,  methods: &#123;    verifyWord () &#123;      if (this.iText.trim() !== &#x27;&#x27;) &#123;        this.vword = this.iText        // 此处调用api      &#125;    &#125;,    debounce (func, delay)&#123;      // let timer = null  定时器不能在此处定义！！      let context = this      let args = arguments      console.log(this)  // --&gt; VueComponent      return function () &#123;        // console.log(this)  --&gt; undefined        clearTimeout(context.timer)        context.timer = setTimeout(()=&gt; &#123;          func.apply(context, args)        &#125;, delay)      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&#x27;scss&#x27;&gt;#addword &#123;  border: 1px solid black;&#125;&lt;/style&gt;\n\n\n\n总结\n防抖函数的基本原理不在此赘述，只针对个人vue项目中的坑，做一个总结  \n\n防抖函数(debounce)返回值是一个函数，通过@input监听时，需要再次调用，否则不执行\n定时器timer定义在data中，而非debounce函数中的原因\n定义在data中，在vue组件创建时，timer会被创建，且是唯一的；如果定义在debounce函数中，@input每次触发debounce都会新创建一个独立的timer,防抖失效\n\n\nthis指向\ndebounce函数中的this指向为VueComponent,这点很容易理解，但在函数返回值中的this为undefined(能力有限实在不知道原因)， 所以需要在return之前，将this保存下来，这样才能取消定时器（定时器也在组件中）\n\n\n\n","tags":["vue 防抖"]},{"title":"JS链表","url":"/Ric0o0/2021/05/30/JS%E9%93%BE%E8%A1%A8/","content":"js链表 —— 单向链表1 -&gt; 2 -&gt; 3 -&gt; 4\n反转:\n4 -&gt; 3 -&gt; 2 -&gt; 1\n这一个看明白,其他的就能推出来\n// 单向链表class Node &#123;  // 节点对象    constructor (element) &#123;  // 初始化        this.element = element  // 节点元素        this.next = null  // 指向下一个节点    &#125;&#125;class LinkedList &#123;    constructor () &#123;        this.size = 0  // 链表大小        this.head = null  // 头节点指向    &#125;        // 在链表最后添加元素    append (element) &#123;        let node = new Node(element);        // 判断链表是否为空        if (this.size === 0)&#123;            this.head = node;        &#125; else &#123;            // 不为空, 就要找到最后一个节点            let lastNode = this.getNode(this.size - 1)            lastNode.next = node  // 给最后一个元素的next一个指向,就算添加完成        &#125;        this.size++    &#125;        // 在链表position位置添加    appendAt (position, element) &#123;        // 边界判断        // position === this.size -&gt; 在最后一个元素之后添加        if (position &lt; 0 || position &gt; this.size)&#123;             throw new Error(&#x27;out of range&#x27;);        &#125;        // 在position位置添加, node.next = nextNode.next ; preNode.next = node        let node = new Node(element);        if (position === 0)&#123; // 在头元素添加            node.next = this.head            this.head = node        &#125; else &#123;            let preNode = this.getNode(position - 1)            node.next = preNode.next            preNode.next = node;        &#125;        this.size++    &#125;        // 删除  只需要改变节点的next指向即可    remove (position) &#123;        // 边界判断        if (position &lt; 0|| position &gt;= this.size)&#123;            throw new Error(&#x27;out of range&#x27;)        &#125;        // pos = 0  --&gt; this.head = delNode.next        // pos !- 0 --&gt; pre.next = delNode.next        if (position === 0)&#123;            let node = this.getNode(position)            this.head = node.next        &#125; else &#123;            let preNode = this.getNode(position - 1)  // 被删除的前一个的next            preNode.next = preNode.next.next        &#125;        this.size--    &#125;        // 根据元素找下标    indexOf (element) &#123;        let current = this.head        for (let i = 0; i &lt; this.size; i++)&#123;            if (current.element === element)&#123;                return i            &#125;            current = current.next;        &#125;        return -1    &#125;        // 反转链表    reserve()&#123;        let pre = null;        let next = null;        while(this.head !== null) &#123;            next = this.head.next;  // next = 头节点的下一个节点            this.head.next = pre;  // 当前头节点的next指向上一个节点            pre = this.head;  // 上一个节点等于当前头节点            if (next === null)&#123;  // 如果next = null 表示之后没有了,当前是最后一个 跳出程序                break            &#125;            this.head = next;  // 头节点后移一个        &#125;    &#125;\t    // 在链表中删除指定的元素    removeElement(element)&#123;        // 找到第一个不需要删除的位置        while (this.head === element)&#123;            this.size--            this.head = this.head.next; // head: 定格在第一个不等于element的节点        &#125;        let pre = this.head;  // pre: 前一个不等于element的节点        let cur = this.head;  // cur: 当前节点        while(cur !== null)&#123;            if (cur.element === element)&#123;                // 当前节点的element 与 输入的element相同 , 要删除 , 就将pre.next指向当前节点的下一个节点                pre.next = cur.next;                this.size--            &#125; else &#123;                pre = cur;  // 如果不相等, 让pre等于当前节点            &#125;            // 在循环最后 cur 要等于cur的下一个节点, 来保证while运行            cur = cur.next;        &#125;    &#125;        getNode(index)&#123;        if (index &lt; 0 || index &gt;= this.size)&#123;            throw new Error(&#x27;out of range&#x27;);        &#125;        let current = this.head;        for (let i = 0; i &lt; index; i++)&#123;            current = current.next        &#125;        return current    &#125;&#125;let li = new LinkedList()li.append(1)li.append(2)li.appendAt(2, 3)li.appendAt(3, 4)li.appendAt(3, 5)li.remove(3)console.log(li.indexOf(1))console.log(li.indexOf(4))console.dir(li, &#123;    depth: 100&#125;)\n\n\n\n\n\n","tags":["JS链表"]},{"title":"归并排序","url":"/Ric0o0/2021/06/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","content":"归并排序arr = [3, 4, 2, 1] 将arr升序排序\n先进入arr的左侧, 将arr不断一分为二, 直到只有一个值为止(这就是base case, 即 l = r), 如图, 左 3 , 右 4, 然后将这两个数排序 –&gt; arr = [3, 4, 2, 1] ; 这时候进入数组右侧, 依旧不断一分为二, 直到base case, 左 2 右 1, 将这两个数排序 –&gt; arr = [3, 4, 1, 2] ; \n最后回到arr的最外层, 然后排序, 以此为例解释merge函数的过程:\n现在的数组是 3 4 1 2\n\n3 和 1 比较 –&gt; 3比1大 –&gt; 让help[0] = 1, 然后p2指针+1\n 3 和 2 比    –&gt;  3大于2 –&gt; help[1] = 2 , p2指针+1 , 注意此时p2已经越界, 无法再比较\n 直接把 3 4 添加进help\n让arr[l + i] = help[i] , 把help中的值全部拷贝给arr, 但是此时是以最终形式为例(l = 0), 如果此时要拷贝的是arr的右半部分, 必须得是 l + i , 否则就乱了\n\n从下一级不断向上一级排序, 上一级排序是在下一级已经排好的基础上进行排序, 所以当p1或p2越界时, 可以直接无脑把剩下值的拷贝进help// 递归版本/**       [3 4 2 1]*        /     \\*      3 4     2 1*      / \\     /  \\*     3   4    2   1* */// let arr = [3, 4, 2, 1]let arr = generateRandomArray(1000000, 100000)let time0 = new Date()rank(arr, 0, arr.length-1)let time1 = new Date()console.log(arr)console.log(time1 - time0 + &#x27;ms&#x27;)function rank(arr, l, r)&#123;    return process(arr, l, r)&#125;function process (arr, l, r) &#123;    if (l === r)&#123; // base case        return;    &#125;    let mid = l + ((r - l) &gt;&gt; 1)    process(arr, l, mid)  // 左侧排序    process(arr, mid+1, r)  // 右侧排序    merge(arr, l, mid, r)  // 左右全部排序    return arr&#125;function merge (arr, l, mid, r) &#123;    let p1 = l;  // 左侧指针, 负责左侧(l - mid)    let p2 = mid + 1  // 右侧指针, 负责右侧    let help = new Array(r-l+1)  // 辅助数组, 长度为规定的r - l +1     let i = 0  // 辅助索引    while (p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123;  // 只有p1 和 p2都不越界时才有效        // 如果把p1放入help中, p1++, 否则p2++  p1/p2一次只加一个, 最终一定有一个先越界        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++]    &#125;    // 下面两个while只会运行一个    while (p1 &lt;= mid)&#123;  // p2越界之后, 直接把arr[p1 ~ mid] 的值直接放到help中        help[i++] = arr[p1++]    &#125;    while(p2 &lt;= r)&#123;  // p1越界后, 直接把arr[p2 ~ r] 的值直接放到help中        help[i++] = arr[p2++]    &#125;    for (let i = 0; i &lt; help.length; i++)&#123;        arr[l + i] = help[i]  // 把help中的值,拷贝到对应的arr中, 所以 l + i    &#125;    // console.log(`第$&#123;count++&#125;次: $&#123;arr&#125;`)&#125;// 对数器function generateRandomArray(maxSize, maxValue) &#123;    let arr = []    for (let i = 0; i &lt; Math.random()* (maxSize + 1); i++)&#123;        arr.push((Math.random() * (maxValue + 1)) - (Math.random() * (maxValue +1 )))    &#125;    console.log(arr)    console.log(arr.length)    return arr&#125;\n\n","tags":["归并排序"]},{"title":"我的第一篇blog","url":"/Ric0o0/2021/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/","content":"hexo 指令hexo n (new)创建新文章\nhexo s (server)在本地预览\nhexo clean 清除缓存与已生成的静态文件\nhexo g (generate)生成静态文件\nhexo d (deploy)部署\n\n参考文献www.codesheep.cn\n","tags":["hexo"]},{"title":"js双向链表_队列_栈_环形数组","url":"/Ric0o0/2021/06/02/js%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-%E9%98%9F%E5%88%97-%E6%A0%88/","content":"// 双向链表class Node &#123;    constructor (element) &#123;        this.element = element // 元素        this.last = null // 上一指针        this.next = null // 下一指针    &#125;&#125;class DoubleLinkedList &#123;    constructor () &#123;        this.head = null  // 链表头        this.tail = null  // 链表尾    &#125;        // 从头部添加    addFromHead (element) &#123;        let node = new Node(element)        // 判断this.head是否为空        if (this.head === null) &#123;            this.head = node            this.tail = node        &#125; else &#123;            this.head.last = node  // 原来的头节点last指向新节点            node.next = this.head // 新节点的next指向原来的头节点            this.head = node // head指向新节点        &#125;    &#125;        // 从尾部添加    addFromTail (element) &#123;        let node = new Node(element)        // 判断this.head是否为空        if (this.head === null) &#123;            this.head = node            this.tail = node        &#125; else &#123;            node.last = this.tail            this.tail.next = node            this.tail = node        &#125;    &#125;        // 从头部弹出    popFromHead () &#123;        if (this.head === null) &#123;            return null        &#125;        let popNode = this.head        // 只有一个节点        if (this.head === this.tail) &#123;            this.head = null            this.tail = null        &#125; else &#123;            // 正常情况            this.head = popNode.next            this.head.last = null            popNode.next = null        &#125;        return popNode    &#125;        // 从尾部弹出    popFromTail () &#123;        if (this.tail === null) &#123;            return null        &#125;        let popNode = this.tail        if (this.head === this.tail) &#123;            this.head = null            this.tail = null        &#125; else &#123;            this.tail = popNode.last            this.tail.next = null            popNode.last = null        &#125;        return popNode    &#125;&#125;// let dll = new DoubleLinkedList()// dll.addFromHead(3)// dll.addFromHead(2)// dll.addFromHead(1)//// dll.addFromTail(4)// console.log(dll.popFromTail())// console.dir(dll, &#123;depth: 100&#125;)class MyQueue &#123;    // 先进先出  头进尾出    constructor () &#123;        this.length = 0        this.queue = new DoubleLinkedList()    &#125;        push (element) &#123;        this.length++        this.queue.addFromHead(element)    &#125;        pop () &#123;        this.length--        return this.queue.popFromTail()    &#125;    &#125;// let mq = new MyQueue();// mq.push(1)// mq.push(2)// mq.push(3)// console.log(mq.pop())// console.dir(mq, &#123;depth: 100&#125;)class MyStack &#123;    constructor () &#123;        this.stack = new DoubleLinkedList()        this.length = 0    &#125;        push (element) &#123;        this.stack.addFromHead(element)        this.length++    &#125;        pop () &#123;        this.length--        return this.stack.popFromHead()    &#125;    &#125;// let ms = new MyStack();// ms.push(1)// ms.push(2)// ms.push(3)// console.log(ms.pop())// console.dir(ms, &#123;depth: 100&#125;);class MyArray &#123;    constructor (limit) &#123;        this.limit = limit        this.size = 0        this.pushi = 0  // 添加索引        this.polli = 0  // 弹出索引        this.arr = []    &#125;        push (value) &#123;        if (this.size === this.limit) &#123;            throw new Error(&#x27;满了!&#x27;)        &#125;        this.arr[this.pushi] = value;        this.size++        this.pushi = this.nextIndex(this.pushi);        // console.log(&#x27;pushi: &#x27;, this.pushi, &#x27;val: &#x27; , value)        // console.log(this.arr)    &#125;        pop()&#123;        if (this.size === 0)&#123;            throw new Error(&#x27;空的!&#x27;)        &#125;        let res = this.arr[this.polli];        this.size--;        this.polli = this.nextIndex(this.polli)        return console.log(res)    &#125;        nextIndex (i) &#123;        return i &lt; this.limit - 1 ? i+1 : 0  // 不能写i++    &#125;    printArr()&#123;        return console.log(this.arr)    &#125;    &#125;// let marr = new MyArray(5)// marr.push(0)// marr.push(1)// marr.push(2)// marr.push(3)// marr.push(4)// marr.pop()// marr.pop()// marr.pop()// marr.pop()// marr.pop()// marr.push(5)// marr.push(6)// marr.push(7)// marr.push(8)// marr.push(9)// marr.pop()// marr.pop()// marr.pop()// marr.pop()// marr.pop()// marr.printArr()\n\n"},{"title":"栈实现队列--队列实现栈","url":"/Ric0o0/2021/06/10/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/","content":"用栈实现队列, 用队列实现栈// 用栈实现队列// 队列: 先进先出class MyQueenByStack &#123;    // 用两个栈实现队列, 栈特性先进后出, 用两个栈来倒    constructor () &#123;        this.pushStack = [];        this.popStack = [];    &#125;    push(val)&#123;        this.pushStack.push(val)    &#125;        poll()&#123;        if (this.pushStack.length === 0 &amp;&amp; this.popStack.length === 0)&#123;            console.log(&#x27;queue is empty!&#x27;)            return -1        &#125;        this.pushToPop()        return this.popStack.pop()    &#125;    pushToPop() &#123;        // 在需要弹出栈的时候, 将pushStack中的数据倒入popStack, 让先进的在第一个弹出来        // 只有在popStack中没有元素的时候才能倒, 否则就乱套了        if (this.popStack.length === 0) &#123;            while (this.pushStack.length !== 0) &#123;                this.popStack.push(this.pushStack.pop())            &#125;        &#125;    &#125;    &#125;// let mq = new MyQueenByStack()// mq.push(1)// mq.push(2)// mq.push(3)// mq.push(4)// console.log(mq.poll())// console.log(mq.poll())// 队列实现栈class MyStackByQueues &#123;    constructor () &#123;        this.dataQueue = [];        this.helpQueue = [];    &#125;    push(val)&#123;        this.dataQueue.push(val);    &#125;    //两个队列    //  data:  [5 4 3 2 1]  想把1提出来    //  help:  []        //  要提出5    //  data:  [1]    //  help:  [5 4 3 2]    pop()&#123;        if (this.dataQueue.length === 0 &amp;&amp; this.helpQueue.length === 0)&#123;            throw new Error(&#x27;stack is empty!&#x27;)        &#125;        this.convert()        return this.helpQueue[0]    &#125;    convert()&#123;        while (this.dataQueue.length !== 1)&#123;            this.helpQueue.push(this.dataQueue.shift())        &#125;        // 让 dataQueue 永远是数据多的  ;  helpQueue 永远是要弹出的                [this.dataQueue, this.helpQueue] = [this.helpQueue, this.dataQueue] // 数组互换    &#125;&#125;let mq = new MyStackByQueues()mq.push(5)mq.push(4)mq.push(3)mq.push(2)mq.push(1)console.log(mq.pop())\n\n"},{"title":"超级水王","url":"/Ric0o0/2021/05/28/%E8%B6%85%E7%BA%A7%E6%B0%B4%E7%8E%8B/","content":"超级水王在一个数组中，有一个数a出现的次数，大于数组长度N的一半，称a为水王数，找出a假设有一个数组[1,3, 2, 3 ,1 ,2 ,2 , 3, 3 ,1 ,3 , 3, 3]\nN ：13\n1: 3次\n2: 3次\n3: 7次 (水王)\n使用常规方法： 遍历数组，同时创建{1:3， 2:3， 3:7} ， 然后在对象中找出出现次数最多的\n\n如何更优雅的找出水王？\n直接上代码\nfunction func (arr) &#123;    // 对传入的数据做筛除， 不能为空， 长度不能为0    if (arr === null || arr.length === 0) &#123;        return -1    &#125;    // -------------------------------    let candidate = null  // 候选值    let restHP = 0  // 剩余血量    for (let cur of arr) &#123;        if (restHP === 0) &#123; // 没有候选            candidate = cur            restHP = 1        &#125; else if (cur !== candidate) &#123; // 当前值 不等于 候选            restHP--        &#125; else &#123;  // 当前值等于候选            restHP++        &#125;    &#125;    // -------------------------------    if (restHP === 0) &#123;        console.log(&#x27;null&#x27;)        return -1    &#125;    // -------------------------------    let count = 0    for (let num of arr) &#123;        if (num === candidate) &#123;            count++        &#125;    &#125;    // arr.length &gt;&gt; 1 = arr.length / 2    return count &gt; (arr.length &gt;&gt; 1) ? console.log(candidate) : console.log(&#x27;null&#x27;)    &#125;\n\n\n\n\n在最开始初始化两个变量， 候选者candidate=null， 剩余血量restHP = 0, \n循环遍历数组， 把arr[0]给candidate， 并且赋予它1点血量， restHP=1\n\n\n继续遍历, 如果arr[1] 与 candidate(就是arr[0]) 相等，那么再给它1点血量, restHP = 2 \n如果arr[1] 与 candidate 不相等，就会打掉candidate 1点血量， restHP = 0\n\n综上， 每次循环都会碰见遇到3种情况：\n\nrestHP === 0  –&gt; 需要把当前值赋给candidate, 并且 给restHP 1点血量， restHP = 1\narr[i] === candidate  –&gt;  值相同，意味着队伍壮大，就会多一点血量  restHP++\narr[i] !== candidate   –&gt;  值不相同，就需要牺牲一点血量一换一， 所以restHP–\n\n完全遍历完成以后，程序会有两种情况\n\nrestHP === 0 –&gt; 每一个数都被消耗殆尽， 没有坚持到最后的数, 所以直接return -1\n\nrestHP !== 0  –&gt;  \n\n真的有一个数坚挺到最后\n假象\n\n不管是哪个，我们都需要再遍历一次，很简单，定义一个count = 0, 如果遍历到元素与当前candidate相同， count++\n最后，看count的值，是否大于arr.length的一半， 如果是， 那就是真的； 不是，那就是个骗子 \n\n\n"},{"title":"WPF MVVM下按钮命令绑定","url":"/Ric0o0/2023/02/23/wpf/WPF%20MVVM%E4%B8%8B%E6%8C%89%E9%92%AE%E5%91%BD%E4%BB%A4%E7%BB%91%E5%AE%9A/","content":"WPF MVVM框架下按钮命令绑定需求：\n\n在输入框内无内容时，Click me按钮不可用\n点击Close Window按钮关闭窗口\n\n效果：\n目录结构：\n\n\n\n\n\napp.xaml中 StartupUri=&quot;./View/MainWindow.xaml&quot;nuget: 安装 Microsoft.Xaml.Behaviors.Wpf\nMainWindow.xaml\n&lt;Window x:Class=&quot;MVVMTest1.MainWindow&quot;        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;        xmlns:local=&quot;clr-namespace:MVVMTest1&quot;        xmlns:vm =&quot;clr-namespace:MVVMTest1.ViewModel&quot;  ViewModel命名空间        xmlns:i=&quot;http://schemas.microsoft.com/xaml/behaviors&quot;  引入behavior命名空间        xmlns:behavior=&quot;clr-namespace:MVVMTest1.Behavior&quot;        mc:Ignorable=&quot;d&quot;        Title=&quot;MainWindow&quot; Height=&quot;450&quot; Width=&quot;800&quot;        &gt;    &lt;i:Interaction.Behaviors&gt;        &lt;behavior:WindowBehavior IsClose=&quot;&#123;Binding WindowClose&#125;&quot;/&gt;    &lt;/i:Interaction.Behaviors&gt;    &lt;Window.DataContext&gt;        &lt;vm:MainWindowViewModel/&gt;  datacontext    &lt;/Window.DataContext&gt;    &lt;StackPanel HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; TextElement.FontSize=&quot;32&quot;&gt;        &lt;TextBox Width=&quot;300&quot; Height=&quot;40&quot; Text=&quot;&#123;Binding Text, UpdateSourceTrigger=PropertyChanged&#125;&quot;/&gt;        &lt;Button Width=&quot;150&quot; Height=&quot;50&quot; Margin=&quot;0,20,0,0&quot; Content=&quot;click me&quot; Command=&quot;&#123;Binding ClickCommand&#125;&quot;/&gt;        &lt;Button Content=&quot;Close Window&quot;                 Command=&quot;&#123;Binding CloseWindowCommand&#125;&quot;                 /&gt;    &lt;/StackPanel&gt;&lt;/Window&gt;\n\nMainWindow.xaml.cs\npublic partial class MainWindow : Window    &#123;        public MainWindow()        &#123;            InitializeComponent();        &#125;    &#125;\n\nBaseCommand.cs\npublic class BaseCommand : ICommand    &#123;        public event EventHandler CanExecuteChanged  // 不加下面这俩 add remove，CanExecute只会触发一次！！！        &#123;            add &#123; CommandManager.RequerySuggested += value; &#125;            remove &#123; CommandManager.RequerySuggested -= value; &#125;        &#125;        public bool CanExecute(object parameter)        &#123;            return DoCanExecute?.Invoke(parameter) == true;        &#125;        public void Execute(object parameter)        &#123;            DoExecute?.Invoke(parameter);        &#125;        public Action&lt;object&gt; DoExecute &#123; get; set; &#125;        public Func&lt;object, bool&gt; DoCanExecute &#123; get; set; &#125;    &#125;\n\nBaseViewModel.cs\npublic class BaseViewModel : INotifyPropertyChanged    &#123;        public event PropertyChangedEventHandler PropertyChanged;        public void OnPropertyChanged([CallerMemberName] string propName = &quot;&quot;)        &#123;            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propName));        &#125;    &#125;\n\nMainWindowViewModel.cs\npublic class MainWindowViewModel : BaseViewModel    &#123;        private string text;        public string Text        &#123;            get &#123; return text; &#125;            set &#123; text = value; OnPropertyChanged(); &#125;        &#125;        private bool windowClose;        public bool WindowClose        &#123;            get &#123; return windowClose; &#125;            set &#123; windowClose = value; OnPropertyChanged(); &#125;        &#125;        public BaseCommand ClickCommand &#123; get; set; &#125;        public BaseCommand CloseWindowCommand &#123; get; set; &#125;        public MainWindowViewModel()        &#123;            ClickCommand = new BaseCommand();            ClickCommand.DoCanExecute = new Func&lt;object, bool&gt;((o) =&gt; !string.IsNullOrEmpty(Text)); ;            ClickCommand.DoExecute = new Action&lt;object&gt;((o) =&gt;            &#123;                Text = &quot;1234&quot;;            &#125;);            CloseWindowCommand = new BaseCommand();            CloseWindowCommand.DoCanExecute = new Func&lt;object, bool&gt;((o)=&gt; true);            CloseWindowCommand.DoExecute = new Action&lt;object&gt;((o) =&gt;            &#123;                WindowClose = true;            &#125;);        &#125;    &#125;\n\npublic class WindowBehavior : Behavior&lt;Window&gt;    &#123;        // 快捷键 propdp两次tab        public bool IsClose        &#123;            get &#123; return (bool)GetValue(IsCloseProperty); &#125;            set &#123; SetValue(IsCloseProperty, value); &#125;        &#125;        public static readonly DependencyProperty IsCloseProperty =            DependencyProperty.Register(&quot;IsClose&quot;, typeof(bool), typeof(WindowBehavior), new PropertyMetadata(false, OnClosePropertyChanged));        private static void OnClosePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)        &#123;            Window window = d as Window;            bool newVal = (bool)e.NewValue;            if (newVal)            &#123;                window.Close();            &#125;        &#125;    &#125;\n\n\n\n\n\n"}]